<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yibei Yu, Fuhan Zhang, Jonathan Leon">

<title>Regression, Classification, and Topic Insights – ad688-employability-Fa2501-group12</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">ad688-employability-Fa2501-group12</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./research_introduction.html"> 
<span class="menu-text">Research Introduction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data_cleaning.qmd/ipynb"> 
<span class="menu-text">Data Cleaning &amp; Exploration</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./eda.qmd/ipynb"> 
<span class="menu-text">Exploratory Data Analysis</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./skill_gap_analysis.qmd/ipynb"> 
<span class="menu-text">Skill Gap Analysis</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ml_methods.qmd/ipynb"> 
<span class="menu-text">ML Methods</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./nlp_methods.qmd/ipynb"> 
<span class="menu-text">NLP Methods</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./career_plan.html"> 
<span class="menu-text">Career Plan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">0.1</span> Introduction</a></li>
  <li><a href="#analysis" id="toc-analysis" class="nav-link" data-scroll-target="#analysis"><span class="header-section-number">1</span> Analysis</a>
  <ul class="collapse">
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">1.1</span> Conclusion</a></li>
  </ul></li>
  <li><a href="#analysis-1" id="toc-analysis-1" class="nav-link" data-scroll-target="#analysis-1"><span class="header-section-number">2</span> Analysis</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Regression, Classification, and Topic Insights</h1>
<p class="subtitle lead">Analyzing Salary and Industry Trends for ML/Data Science Roles</p>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Yibei Yu, Fuhan Zhang, Jonathan Leon </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Boston University
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="introduction" class="level2" data-number="0.1">
<h2 data-number="0.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">0.1</span> Introduction</h2>
<p>This module extends previous analyses by applying <strong>machine-learning clustering and regression models</strong> to identify salary patterns across industries, contrasting jobs that require machine learning (ML) / data-science (DS) skills with those that do not.</p>
<div id="0b283365" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> missingno <span class="im">as</span> msno</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>sns.set_theme(style<span class="op">=</span><span class="st">"whitegrid"</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>os.makedirs(<span class="st">"figures"</span>, exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>csv_path <span class="op">=</span> <span class="st">"data/lightcast_job_postings.csv"</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(csv_path):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"Data file not found: </span><span class="sc">{</span>csv_path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Place the dataset in the `data/` folder or update the path. Skipping data load."</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> <span class="va">None</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> pd.read_csv(csv_path)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Columns in dataset:"</span>, df.columns.tolist())</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># close previous python block and start a new one for analysis</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_6242/951617275.py:18: DtypeWarning:

Columns (19,30) have mixed types. Specify dtype option on import or set low_memory=False.
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Columns in dataset: ['ID', 'LAST_UPDATED_DATE', 'LAST_UPDATED_TIMESTAMP', 'DUPLICATES', 'POSTED', 'EXPIRED', 'DURATION', 'SOURCE_TYPES', 'SOURCES', 'URL', 'ACTIVE_URLS', 'ACTIVE_SOURCES_INFO', 'TITLE_RAW', 'BODY', 'MODELED_EXPIRED', 'MODELED_DURATION', 'COMPANY', 'COMPANY_NAME', 'COMPANY_RAW', 'COMPANY_IS_STAFFING', 'EDUCATION_LEVELS', 'EDUCATION_LEVELS_NAME', 'MIN_EDULEVELS', 'MIN_EDULEVELS_NAME', 'MAX_EDULEVELS', 'MAX_EDULEVELS_NAME', 'EMPLOYMENT_TYPE', 'EMPLOYMENT_TYPE_NAME', 'MIN_YEARS_EXPERIENCE', 'MAX_YEARS_EXPERIENCE', 'IS_INTERNSHIP', 'SALARY', 'REMOTE_TYPE', 'REMOTE_TYPE_NAME', 'ORIGINAL_PAY_PERIOD', 'SALARY_TO', 'SALARY_FROM', 'LOCATION', 'CITY', 'CITY_NAME', 'COUNTY', 'COUNTY_NAME', 'MSA', 'MSA_NAME', 'STATE', 'STATE_NAME', 'COUNTY_OUTGOING', 'COUNTY_NAME_OUTGOING', 'COUNTY_INCOMING', 'COUNTY_NAME_INCOMING', 'MSA_OUTGOING', 'MSA_NAME_OUTGOING', 'MSA_INCOMING', 'MSA_NAME_INCOMING', 'NAICS2', 'NAICS2_NAME', 'NAICS3', 'NAICS3_NAME', 'NAICS4', 'NAICS4_NAME', 'NAICS5', 'NAICS5_NAME', 'NAICS6', 'NAICS6_NAME', 'TITLE', 'TITLE_NAME', 'TITLE_CLEAN', 'SKILLS', 'SKILLS_NAME', 'SPECIALIZED_SKILLS', 'SPECIALIZED_SKILLS_NAME', 'CERTIFICATIONS', 'CERTIFICATIONS_NAME', 'COMMON_SKILLS', 'COMMON_SKILLS_NAME', 'SOFTWARE_SKILLS', 'SOFTWARE_SKILLS_NAME', 'ONET', 'ONET_NAME', 'ONET_2019', 'ONET_2019_NAME', 'CIP6', 'CIP6_NAME', 'CIP4', 'CIP4_NAME', 'CIP2', 'CIP2_NAME', 'SOC_2021_2', 'SOC_2021_2_NAME', 'SOC_2021_3', 'SOC_2021_3_NAME', 'SOC_2021_4', 'SOC_2021_4_NAME', 'SOC_2021_5', 'SOC_2021_5_NAME', 'LOT_CAREER_AREA', 'LOT_CAREER_AREA_NAME', 'LOT_OCCUPATION', 'LOT_OCCUPATION_NAME', 'LOT_SPECIALIZED_OCCUPATION', 'LOT_SPECIALIZED_OCCUPATION_NAME', 'LOT_OCCUPATION_GROUP', 'LOT_OCCUPATION_GROUP_NAME', 'LOT_V6_SPECIALIZED_OCCUPATION', 'LOT_V6_SPECIALIZED_OCCUPATION_NAME', 'LOT_V6_OCCUPATION', 'LOT_V6_OCCUPATION_NAME', 'LOT_V6_OCCUPATION_GROUP', 'LOT_V6_OCCUPATION_GROUP_NAME', 'LOT_V6_CAREER_AREA', 'LOT_V6_CAREER_AREA_NAME', 'SOC_2', 'SOC_2_NAME', 'SOC_3', 'SOC_3_NAME', 'SOC_4', 'SOC_4_NAME', 'SOC_5', 'SOC_5_NAME', 'LIGHTCAST_SECTORS', 'LIGHTCAST_SECTORS_NAME', 'NAICS_2022_2', 'NAICS_2022_2_NAME', 'NAICS_2022_3', 'NAICS_2022_3_NAME', 'NAICS_2022_4', 'NAICS_2022_4_NAME', 'NAICS_2022_5', 'NAICS_2022_5_NAME', 'NAICS_2022_6', 'NAICS_2022_6_NAME']</code></pre>
</div>
</div>
<div id="b466b4a0" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- classify ML/Data-Science skills and cluster by salary ---</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> safe_tokens(val):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> pd.isna(val):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> []</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> <span class="bu">str</span>(val)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># handle Python lists</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span>:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> ast</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    parsed <span class="op">=</span> ast.literal_eval(s)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(parsed, (<span class="bu">list</span>, <span class="bu">tuple</span>, <span class="bu">set</span>)):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> [<span class="bu">str</span>(x).strip() <span class="cf">for</span> x <span class="kw">in</span> parsed <span class="cf">if</span> x <span class="kw">not</span> <span class="kw">in</span> (<span class="va">None</span>, <span class="st">''</span>)]</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># split on common separators</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  parts <span class="op">=</span> re.split(<span class="vs">r"\||;|\\n|\\r|\\t|,"</span>, s)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> [p.strip().strip(<span class="st">'</span><span class="ch">\"\'</span><span class="st">'</span>) <span class="cf">for</span> p <span class="kw">in</span> parts <span class="cf">if</span> p.strip()]</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="co"># keywords to mark ML/DS-related skills</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>ml_keywords <span class="op">=</span> [</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="st">'machine learning'</span>,<span class="st">'data science'</span>,<span class="st">'deep learning'</span>,<span class="st">'neural'</span>,<span class="st">'tensorflow'</span>,<span class="st">'pytorch'</span>,</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  <span class="st">'scikit'</span>,<span class="st">'sklearn'</span>,<span class="st">'xgboost'</span>,<span class="st">'lightgbm'</span>,<span class="st">'pandas'</span>,<span class="st">'numpy'</span>,<span class="st">'nlp'</span>,<span class="st">'natural language'</span>,</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  <span class="st">'computer vision'</span>,<span class="st">'keras'</span>,<span class="st">'statistics'</span>,<span class="st">'statistical'</span>,<span class="st">'rnn'</span>,<span class="st">'cnn'</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ml_tokens(tokens):</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  cnt <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> t <span class="kw">in</span> tokens:</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    low <span class="op">=</span> t.lower()</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> ml_keywords:</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> k <span class="kw">in</span> low:</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        cnt <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cnt</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="co"># combine several skill/name columns to form a token set per posting</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>skill_cols <span class="op">=</span> [<span class="st">'SKILLS_NAME'</span>,<span class="st">'SPECIALIZED_SKILLS_NAME'</span>,<span class="st">'COMMON_SKILLS_NAME'</span>,<span class="st">'SOFTWARE_SKILLS_NAME'</span>]</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> skill_cols:</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> c <span class="kw">not</span> <span class="kw">in</span> df.columns:</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    df[c] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_tokens_row(row):</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>  toks <span class="op">=</span> []</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> c <span class="kw">in</span> skill_cols:</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    toks.extend(safe_tokens(row.get(c, <span class="st">''</span>)))</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> toks</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'all_skill_tokens'</span>] <span class="op">=</span> df.<span class="bu">apply</span>(build_tokens_row, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'ml_skill_count'</span>] <span class="op">=</span> df[<span class="st">'all_skill_tokens'</span>].<span class="bu">apply</span>(count_ml_tokens)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'n_skills'</span>] <span class="op">=</span> df[<span class="st">'all_skill_tokens'</span>].<span class="bu">apply</span>(<span class="bu">len</span>)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a><span class="co"># build a salary numeric column: prefer SALARY (if present) else average of SALARY_FROM/SALARY_TO</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'SALARY'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'salary_num'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'SALARY'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>  sf <span class="op">=</span> pd.to_numeric(df.get(<span class="st">'SALARY_FROM'</span>, pd.Series([<span class="va">None</span>]<span class="op">*</span><span class="bu">len</span>(df))), errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  st <span class="op">=</span> pd.to_numeric(df.get(<span class="st">'SALARY_TO'</span>, pd.Series([<span class="va">None</span>]<span class="op">*</span><span class="bu">len</span>(df))), errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'salary_num'</span>] <span class="op">=</span> sf</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>  <span class="co"># if both available, take mean</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>  df.loc[<span class="op">~</span>sf.isna() <span class="op">&amp;</span> <span class="op">~</span>st.isna(), <span class="st">'salary_num'</span>] <span class="op">=</span> (sf <span class="op">+</span> st)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a><span class="co"># keep rows with a positive salary</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>df_model <span class="op">=</span> df[df[<span class="st">'salary_num'</span>].notna() <span class="op">&amp;</span> (df[<span class="st">'salary_num'</span>]<span class="op">&gt;</span><span class="dv">0</span>)].copy()</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> df_model.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'No salary data available for clustering.'</span>)</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>  X <span class="op">=</span> df_model[[<span class="st">'salary_num'</span>,<span class="st">'ml_skill_count'</span>,<span class="st">'n_skills'</span>]].fillna(<span class="dv">0</span>).to_numpy()</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>  scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>  Xs <span class="op">=</span> scaler.fit_transform(X)</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cluster into 2 groups (we'll map one group to ML jobs and the other to non-ML)</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>  kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>, n_init<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> kmeans.fit_predict(Xs)</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>  df_model[<span class="st">'cluster'</span>] <span class="op">=</span> labels</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>  <span class="co"># mark ML job by whether it has any ML tokens</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>  df_model[<span class="st">'is_ml_job'</span>] <span class="op">=</span> df_model[<span class="st">'ml_skill_count'</span>]<span class="op">&gt;</span><span class="dv">0</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>  <span class="co"># determine which cluster has the higher proportion of ML jobs and label clusters accordingly</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span>:</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>    cluster_ml_pct <span class="op">=</span> df_model.groupby(<span class="st">'cluster'</span>)[<span class="st">'is_ml_job'</span>].mean()</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> cluster_ml_pct.empty:</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>      ml_cluster <span class="op">=</span> <span class="bu">int</span>(cluster_ml_pct.idxmax())</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>      ml_cluster <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>  <span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>    ml_cluster <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>  df_model[<span class="st">'cluster_is_ml'</span>] <span class="op">=</span> df_model[<span class="st">'cluster'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> c: c <span class="op">==</span> ml_cluster)</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>  df_model[<span class="st">'cluster_label'</span>] <span class="op">=</span> df_model[<span class="st">'cluster_is_ml'</span>].<span class="bu">map</span>({<span class="va">True</span>: <span class="st">'ML cluster'</span>, <span class="va">False</span>: <span class="st">'Non-ML cluster'</span>})</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>  <span class="co"># summarize clusters</span></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>  summary <span class="op">=</span> df_model.groupby(<span class="st">'cluster'</span>).agg(</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>    postings<span class="op">=</span>(<span class="st">'cluster'</span>,<span class="st">'size'</span>),</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>    avg_salary<span class="op">=</span>(<span class="st">'salary_num'</span>,<span class="st">'mean'</span>),</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>    median_salary<span class="op">=</span>(<span class="st">'salary_num'</span>,<span class="st">'median'</span>),</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>    avg_ml_skill_count<span class="op">=</span>(<span class="st">'ml_skill_count'</span>,<span class="st">'mean'</span>),</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>    pct_ml_jobs<span class="op">=</span>(<span class="st">'is_ml_job'</span>, <span class="kw">lambda</span> x: <span class="dv">100</span><span class="op">*</span>x.mean())</span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>  ).sort_index()</span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">Cluster summary (salary and ML presence):'</span>)</span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(summary)</span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>  <span class="co"># show cluster centers in original feature space</span></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>  centers <span class="op">=</span> scaler.inverse_transform(kmeans.cluster_centers_)</span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">Cluster centers (salary_num, ml_skill_count, n_skills):'</span>)</span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i,c <span class="kw">in</span> <span class="bu">enumerate</span>(centers):</span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Cluster </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">:'</span>, c)</span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>  <span class="co"># show top 10 sample postings per cluster that are ML jobs</span></span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">sorted</span>(df_model[<span class="st">'cluster'</span>].unique()):</span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span> <span class="op">+</span> <span class="st">'='</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Cluster </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> — top ML postings (sample)'</span>)</span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>    sample <span class="op">=</span> df_model[(df_model[<span class="st">'cluster'</span>]<span class="op">==</span>i) <span class="op">&amp;</span> (df_model[<span class="st">'is_ml_job'</span>])].head(<span class="dv">10</span>)</span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sample.empty:</span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="st">'  (no ML postings in this cluster)'</span>)</span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> idx,row <span class="kw">in</span> sample.iterrows():</span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> row.get(<span class="st">'TITLE'</span>) <span class="kw">or</span> row.get(<span class="st">'TITLE_NAME'</span>) <span class="kw">or</span> <span class="st">''</span></span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  id=</span><span class="sc">{</span>row<span class="sc">.</span>get(<span class="st">'ID'</span>)<span class="sc">}</span><span class="ss"> | salary=</span><span class="sc">{</span>row<span class="sc">.</span>get(<span class="st">'salary_num'</span>)<span class="sc">:.0f}</span><span class="ss"> | ml_count=</span><span class="sc">{</span>row<span class="sc">.</span>get(<span class="st">'ml_skill_count'</span>)<span class="sc">}</span><span class="ss"> | title=</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Cluster summary (salary and ML presence):
         postings     avg_salary  median_salary  avg_ml_skill_count  \
cluster                                                               
0           20496  107614.271858       106080.0            0.305328   
1           10312  138504.380237       133700.0            2.484678   

         pct_ml_jobs  
cluster               
0          12.987900  
1          52.269201  

Cluster centers (salary_num, ml_skill_count, n_skills):
Cluster 0: [1.07642300e+05 3.05321173e-01 3.73175633e+01]
Cluster 1: [1.38469598e+05 2.48617176e+00 8.37555556e+01]

========================================
Cluster 0 — top ML postings (sample)
  id=2725b337958d2ca49d99a8768741e6090bc6a74d | salary=84678 | ml_count=2 | title=ETCD1DCE2110BB27EB
  id=9608eb18fbcc70dae3f59025cca9993e89cb94a9 | salary=101798 | ml_count=2 | title=ET3037E0C947A02404
  id=a0db3935cdbf3d42e7a79b83f6e8074b329e085b | salary=171600 | ml_count=2 | title=ETA167677FC704C4AD
  id=b1de4586ebd2d2e67680b9c18d543dddef07e47d | salary=70880 | ml_count=2 | title=ET3037E0C947A02404
  id=d1be2dfb08255f7fdad6b302a4190cdf5e422720 | salary=69680 | ml_count=2 | title=ET6DA4FDEAD969847C
  id=8b445797f947f39c25b55c2c572137b71045a8ac | salary=69680 | ml_count=2 | title=ET8E0C473DFBEDF8C8
  id=80b1483d1b8816ec99650ea778bab64adf8c50d6 | salary=69680 | ml_count=2 | title=ET6DA4FDEAD969847C
  id=23f8f04e4a10c70f6d0a28cb74b35ba173d9a7e8 | salary=69680 | ml_count=2 | title=ETA945BF69C78F1F2B
  id=4c6903192f71f03f304f7484b73fd4d9610b1e69 | salary=165500 | ml_count=2 | title=ET13E3A2844323866E
  id=530c8ed958399be5655568d64c3ce2da86f20ff7 | salary=68576 | ml_count=4 | title=ET6B57FB37DA4AA8A8

========================================
Cluster 1 — top ML postings (sample)
  id=229620073766234e814e8add21db7dfaef69b3bd | salary=92962 | ml_count=8 | title=ET1CE3CFA5447376E9
  id=f361bb10174a44d316c48ac7ce669390abbf7c7b | salary=136950 | ml_count=15 | title=ET5AA72D0E18D0EFE5
  id=146621e071735303b16f75333b8593fb3f245ea0 | salary=118560 | ml_count=6 | title=ET0000000000000000
  id=9ec8abde1f4b88863ec96b3523e03f0a39b2e5bf | salary=140756 | ml_count=13 | title=ET9B37BAEB716CCCDA
  id=e68a72d999879ef6969e57be84023c6243716bdc | salary=156038 | ml_count=19 | title=ET00335BE0181594E1
  id=2e9acb4dfcf3979abcb892fdb02e8792cfc74a04 | salary=161840 | ml_count=4 | title=ETC1360A6DCAF5E713
  id=2b9cd1c2f0413e5eee667a0e785f131f3ab50817 | salary=103573 | ml_count=4 | title=ET808060B2DD7A4902
  id=ea8bc28ca5f1e012159fa50e4a17947270431a9a | salary=122500 | ml_count=2 | title=ET3037E0C947A02404
  id=5575c78b966843a96790769924eb8c5335367e23 | salary=71000 | ml_count=8 | title=ET3037E0C947A02404
  id=0625296f2e6627c2261bf27e634bad063442d1de | salary=76460 | ml_count=4 | title=ET29293A7C0D786B75</code></pre>
</div>
</div>
<div id="23bb4480" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Static Matplotlib KMeans scatter: salary (y, log) vs cluster (x jitter), color by NAICS group, outline for ML jobs ---</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> FuncFormatter</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>plot_df <span class="op">=</span> df_model[df_model[<span class="st">'salary_num'</span>].notna() <span class="op">&amp;</span> (df_model[<span class="st">'salary_num'</span>]<span class="op">&gt;</span><span class="dv">0</span>)].copy()</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> plot_df.empty:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'No salary data available for static plotting.'</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="st">'cluster'</span> <span class="kw">not</span> <span class="kw">in</span> plot_df.columns:</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> plot_df[[<span class="st">'salary_num'</span>,<span class="st">'ml_skill_count'</span>,<span class="st">'n_skills'</span>]].fillna(<span class="dv">0</span>).to_numpy()</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    sc <span class="op">=</span> StandardScaler()<span class="op">;</span> Xs <span class="op">=</span> sc.fit_transform(X)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    kmeans_tmp <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>, n_init<span class="op">=</span><span class="dv">10</span>).fit(Xs)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'cluster'</span>] <span class="op">=</span> kmeans_tmp.labels_</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># map which temporary cluster is ML-heavy</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      tmp_ml_pct <span class="op">=</span> plot_df.groupby(<span class="st">'cluster'</span>)[<span class="st">'ml_skill_count'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> s: (s<span class="op">&gt;</span><span class="dv">0</span>).mean())</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>      tmp_ml_cluster <span class="op">=</span> <span class="bu">int</span>(tmp_ml_pct.idxmax())</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>      tmp_ml_cluster <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'cluster_is_ml'</span>] <span class="op">=</span> plot_df[<span class="st">'cluster'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> c: c <span class="op">==</span> tmp_ml_cluster)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'cluster'</span>] <span class="op">=</span> plot_df[<span class="st">'cluster_is_ml'</span>].astype(<span class="bu">int</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Robust NAICS/industry column detection (case-insensitive). Prefer name/title/description columns.</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> re <span class="im">as</span> _re</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>  cols <span class="op">=</span> <span class="bu">list</span>(plot_df.columns)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>  naics_like <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> cols <span class="cf">if</span> _re.search(<span class="vs">r'naics|industry'</span>, c, _re.I)]</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>  naics_name_cols <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> naics_like <span class="cf">if</span> _re.search(<span class="vs">r'name|title|desc|sector'</span>, c, _re.I)]</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>  naics_code_cols <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> naics_like <span class="cf">if</span> _re.search(<span class="vs">r'code|id|num|^naics$'</span>, c, _re.I)]</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> naics_name_cols:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    naics_col <span class="op">=</span> naics_name_cols[<span class="dv">0</span>]</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'naics_group'</span>] <span class="op">=</span> plot_df[naics_col].fillna(<span class="st">'Unknown'</span>).astype(<span class="bu">str</span>)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> naics_like <span class="kw">and</span> naics_code_cols:</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># prefer code column if only codes are present</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    code_col <span class="op">=</span> naics_code_cols[<span class="dv">0</span>]</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'naics_group'</span>] <span class="op">=</span> plot_df[code_col].fillna(<span class="st">'Unknown'</span>).astype(<span class="bu">str</span>).<span class="bu">apply</span>(<span class="kw">lambda</span> v: <span class="ss">f"NAICS </span><span class="sc">{</span>v<span class="sc">}</span><span class="ss">"</span> <span class="cf">if</span> <span class="bu">str</span>(v).strip()<span class="op">!=</span><span class="st">''</span> <span class="cf">else</span> <span class="st">'Unknown'</span>)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> naics_like:</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fallback: use first matching column</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    naics_col <span class="op">=</span> naics_like[<span class="dv">0</span>]</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'naics_group'</span>] <span class="op">=</span> plot_df[naics_col].fillna(<span class="st">'Unknown'</span>).astype(<span class="bu">str</span>)</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    plot_df[<span class="st">'naics_group'</span>] <span class="op">=</span> <span class="st">'Unknown'</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>  top_naics <span class="op">=</span> plot_df[<span class="st">'naics_group'</span>].value_counts().nlargest(<span class="dv">10</span>).index.tolist()</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>  plot_df[<span class="st">'naics_top'</span>] <span class="op">=</span> plot_df[<span class="st">'naics_group'</span>].where(plot_df[<span class="st">'naics_group'</span>].isin(top_naics), <span class="st">'Other'</span>)</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>  plot_df[<span class="st">'ml_flag'</span>] <span class="op">=</span> plot_df[<span class="st">'is_ml_job'</span>]</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>  rng <span class="op">=</span> np.random.default_rng(<span class="dv">6</span>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>  plot_df[<span class="st">'x_jitter'</span>] <span class="op">=</span> plot_df[<span class="st">'cluster'</span>].astype(<span class="bu">int</span>) <span class="op">+</span> rng.normal(<span class="dv">0</span>, <span class="fl">0.12</span>, size<span class="op">=</span><span class="bu">len</span>(plot_df))</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>  <span class="co"># sample for plotting to keep figure readable</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>  sample_df <span class="op">=</span> plot_df.sample(n<span class="op">=</span><span class="bu">min</span>(<span class="dv">20000</span>, <span class="bu">len</span>(plot_df)), random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>  plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>))</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>  groups <span class="op">=</span> sample_df.groupby(<span class="st">'naics_top'</span>)</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>  cmap <span class="op">=</span> plt.get_cmap(<span class="st">'tab10'</span>)</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>  colors <span class="op">=</span> {g: cmap(i <span class="op">%</span> <span class="dv">10</span>) <span class="cf">for</span> i,g <span class="kw">in</span> <span class="bu">enumerate</span>(groups.groups.keys())}</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> g, sub <span class="kw">in</span> groups:</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>    plt.scatter(sub[<span class="st">'x_jitter'</span>], sub[<span class="st">'salary_num'</span>], s<span class="op">=</span><span class="dv">18</span>, alpha<span class="op">=</span><span class="fl">0.65</span>, label<span class="op">=</span>g, color<span class="op">=</span>colors[g])</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>  <span class="co"># outline ML jobs (do not add a legend entry for the outline)</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>  ml_sub <span class="op">=</span> sample_df[sample_df[<span class="st">'ml_flag'</span>]]</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>  plt.scatter(ml_sub[<span class="st">'x_jitter'</span>], ml_sub[<span class="st">'salary_num'</span>], facecolors<span class="op">=</span><span class="st">'none'</span>, edgecolors<span class="op">=</span><span class="st">'k'</span>, s<span class="op">=</span><span class="dv">45</span>, linewidths<span class="op">=</span><span class="fl">0.6</span>,label<span class="op">=</span><span class="st">'ML/DS Job Postings'</span>)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Use linear scale so we can show dollar ticks every $25,000 as requested</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>  plt.yscale(<span class="st">'linear'</span>)</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>  plt.xlabel(<span class="st">'KMeans cluster (jittered)'</span>)</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>  plt.ylabel(<span class="st">'Salary (USD)'</span>)</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>  plt.title(<span class="st">'KMeans clusters: Salary by NAICS group; ML jobs outlined'</span>)</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Label x-axis clusters explicitly: 1 = ML jobs, 0 = Non-ML jobs</span></span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>  cluster_order <span class="op">=</span> <span class="bu">sorted</span>(plot_df[<span class="st">'cluster'</span>].unique())</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>  <span class="co"># map 1-&gt;ML cluster label</span></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>  xtick_labels <span class="op">=</span> []</span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> c <span class="kw">in</span> cluster_order:</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'cluster_label'</span> <span class="kw">in</span> plot_df.columns:</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>      <span class="co"># use cluster_label if present</span></span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>      lab <span class="op">=</span> <span class="st">'Jobs Requiring ML/DS Skills'</span> <span class="cf">if</span> (plot_df[<span class="st">'cluster_label'</span>].iloc[<span class="dv">0</span>] <span class="op">==</span> <span class="st">'ML cluster'</span> <span class="kw">and</span> c<span class="op">==</span><span class="dv">1</span>) <span class="kw">or</span> (plot_df[<span class="st">'cluster_label'</span>].unique().size<span class="op">==</span><span class="dv">2</span> <span class="kw">and</span> plot_df.loc[plot_df[<span class="st">'cluster'</span>]<span class="op">==</span>c,<span class="st">'cluster_label'</span>].iloc[<span class="dv">0</span>]<span class="op">==</span><span class="st">'ML cluster'</span>) <span class="cf">else</span> <span class="st">'Jobs Not Requiring ML/DS Skills'</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>      lab <span class="op">=</span> <span class="st">'Jobs Requiring ML/DS Skills'</span> <span class="cf">if</span> c<span class="op">==</span><span class="dv">1</span> <span class="cf">else</span> <span class="st">'Jobs Not Requiring ML/DS Skills'</span></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>    xtick_labels.append(lab)</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>  plt.xticks(cluster_order, xtick_labels, rotation<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>  <span class="co"># set major y-ticks every $25,000 from min to max salary (rounded)</span></span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>  ymin <span class="op">=</span> math.floor(sample_df[<span class="st">'salary_num'</span>].<span class="bu">min</span>() <span class="op">/</span> <span class="dv">25000</span>) <span class="op">*</span> <span class="dv">25000</span></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>  ymax <span class="op">=</span> math.ceil(sample_df[<span class="st">'salary_num'</span>].<span class="bu">max</span>() <span class="op">/</span> <span class="dv">25000</span>) <span class="op">*</span> <span class="dv">25000</span></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>  y_ticks <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">int</span>(ymin), <span class="bu">int</span>(ymax)<span class="op">+</span><span class="dv">1</span>, <span class="dv">25000</span>))</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>  plt.gca().set_yticks(y_ticks)</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> usd(x, pos):</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f"$</span><span class="sc">{</span>x<span class="sc">:,.0f}</span><span class="ss">"</span></span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a>  plt.gca().yaxis.set_major_formatter(FuncFormatter(usd))</span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>  <span class="co"># keep legend for NAICS groups only, not the ML outline</span></span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>  plt.legend(title<span class="op">=</span><span class="st">'NAICS (top)'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">1.02</span>,<span class="dv">1</span>), loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>  plt.tight_layout()</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a>  out_png <span class="op">=</span> <span class="st">'figures/kmeans_salary_naics_scatter.png'</span></span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>  plt.savefig(out_png, dpi<span class="op">=</span><span class="dv">220</span>)</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'Saved static KMeans NAICS scatter to'</span>, out_png)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Saved static KMeans NAICS scatter to figures/kmeans_salary_naics_scatter.png</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="regression_classification_files/figure-html/cell-4-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="analysis" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Analysis</h1>
<p>The KMeans clustering was run comparing positions that specifically required machine learning or data science skills against those that did not, with identifiers for the top ten industry segments and all others grouped as “Other.” If all positions had been plotted together, it appears there would have been a natural split around the $225,000 salary mark, as postings above that threshold become increasingly sparse. Looking at the two clusters side by side, it’s clear that while both include outliers, roles requiring machine learning or data science skills have not only a higher concentration of positions above the $225,000 mark but also significantly more extreme salary outliers.</p>
<div id="2802fe57" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Multiple linear regression: log(salary) on ML-job indicator, industry fixed effects, and controls ---</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># prefer df_model if available (created during clustering); otherwise fall back to plot_df</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>source_df <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'df_model'</span> <span class="kw">in</span> <span class="bu">globals</span>():</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  source_df <span class="op">=</span> df_model.copy()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="st">'plot_df'</span> <span class="kw">in</span> <span class="bu">globals</span>():</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  source_df <span class="op">=</span> plot_df.copy()</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  source_df <span class="op">=</span> df.copy()</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># ensure salary numeric present</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> source_df <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> source_df.empty <span class="kw">or</span> <span class="st">'salary_num'</span> <span class="kw">not</span> <span class="kw">in</span> source_df.columns:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'No usable salary data available for regression.'</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  df_reg <span class="op">=</span> source_df[source_df[<span class="st">'salary_num'</span>].notna() <span class="op">&amp;</span> (source_df[<span class="st">'salary_num'</span>]<span class="op">&gt;</span><span class="dv">0</span>)].copy()</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> df_reg.empty:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'No salary rows after filtering for regression.'</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># detect NAICS/industry column robustly (same approach as plotting)</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> re <span class="im">as</span> _re</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> <span class="bu">list</span>(df_reg.columns)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    naics_like <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> cols <span class="cf">if</span> _re.search(<span class="vs">r'naics|industry'</span>, c, _re.I)]</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    naics_name_cols <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> naics_like <span class="cf">if</span> _re.search(<span class="vs">r'name|title|desc|sector'</span>, c, _re.I)]</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    naics_code_cols <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> naics_like <span class="cf">if</span> _re.search(<span class="vs">r'code|id|num|^naics$'</span>, c, _re.I)]</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> naics_name_cols:</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>      naics_col <span class="op">=</span> naics_name_cols[<span class="dv">0</span>]</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>      df_reg[<span class="st">'naics_group'</span>] <span class="op">=</span> df_reg[naics_col].fillna(<span class="st">'Unknown'</span>).astype(<span class="bu">str</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> naics_like <span class="kw">and</span> naics_code_cols:</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>      code_col <span class="op">=</span> naics_code_cols[<span class="dv">0</span>]</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>      df_reg[<span class="st">'naics_group'</span>] <span class="op">=</span> df_reg[code_col].fillna(<span class="st">'Unknown'</span>).astype(<span class="bu">str</span>).<span class="bu">apply</span>(<span class="kw">lambda</span> v: <span class="ss">f"NAICS </span><span class="sc">{</span>v<span class="sc">}</span><span class="ss">"</span> <span class="cf">if</span> <span class="bu">str</span>(v).strip()<span class="op">!=</span><span class="st">''</span> <span class="cf">else</span> <span class="st">'Unknown'</span>)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> naics_like:</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>      naics_col <span class="op">=</span> naics_like[<span class="dv">0</span>]</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>      df_reg[<span class="st">'naics_group'</span>] <span class="op">=</span> df_reg[naics_col].fillna(<span class="st">'Unknown'</span>).astype(<span class="bu">str</span>)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>      df_reg[<span class="st">'naics_group'</span>] <span class="op">=</span> <span class="st">'Unknown'</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># build top-industry grouping similar to plotting</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    top_naics <span class="op">=</span> df_reg[<span class="st">'naics_group'</span>].value_counts().nlargest(<span class="dv">10</span>).index.tolist()</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>    df_reg[<span class="st">'naics_top'</span>] <span class="op">=</span> df_reg[<span class="st">'naics_group'</span>].where(df_reg[<span class="st">'naics_group'</span>].isin(top_naics), <span class="st">'Other'</span>)</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create binary indicator: whether the posting requires ML/DS skills</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># keep `is_ml_job` for backwards compatibility with the formula</span></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>    df_reg[<span class="st">'requires_ml_skill'</span>] <span class="op">=</span> df_reg.get(<span class="st">'ml_skill_count'</span>, <span class="dv">0</span>) <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    df_reg[<span class="st">'is_ml_job'</span>] <span class="op">=</span> df_reg[<span class="st">'requires_ml_skill'</span>]</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    df_reg[<span class="st">'log_salary'</span>] <span class="op">=</span> np.log(df_reg[<span class="st">'salary_num'</span>].astype(<span class="bu">float</span>))</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add simple controls if missing</span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'n_skills'</span> <span class="kw">not</span> <span class="kw">in</span> df_reg.columns:</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>      df_reg[<span class="st">'n_skills'</span>] <span class="op">=</span> df_reg.get(<span class="st">'all_skill_tokens'</span>, []).<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="bu">len</span>(x) <span class="cf">if</span> <span class="bu">isinstance</span>(x, (<span class="bu">list</span>, <span class="bu">tuple</span>)) <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'ml_skill_count'</span> <span class="kw">not</span> <span class="kw">in</span> df_reg.columns:</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>      df_reg[<span class="st">'ml_skill_count'</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fit OLS with industry fixed effects and interaction: log_salary ~ is_ml_job * C(naics_top) + n_skills + ml_skill_count</span></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    formula <span class="op">=</span> <span class="st">'log_salary ~ is_ml_job * C(naics_top) + n_skills + ml_skill_count'</span></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>      model <span class="op">=</span> smf.ols(formula<span class="op">=</span>formula, data<span class="op">=</span>df_reg).fit(cov_type<span class="op">=</span><span class="st">'HC3'</span>)</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(model.summary())</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>      <span class="co"># save summary to file</span></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>      <span class="cf">with</span> <span class="bu">open</span>(<span class="st">'figures/ols_summary.txt'</span>, <span class="st">'w'</span>) <span class="im">as</span> f:</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>        f.write(model.summary().as_text())</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="st">'Regression failed:'</span>, e)</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>      model <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If model fit, compute predicted salaries for ML vs non-ML by industry</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>      preds <span class="op">=</span> []</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>      <span class="co"># use mean of numeric controls for prediction</span></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>      mean_n_skills <span class="op">=</span> df_reg[<span class="st">'n_skills'</span>].mean() <span class="cf">if</span> <span class="st">'n_skills'</span> <span class="kw">in</span> df_reg.columns <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>      mean_ml_skill_count <span class="op">=</span> df_reg[<span class="st">'ml_skill_count'</span>].mean() <span class="cf">if</span> <span class="st">'ml_skill_count'</span> <span class="kw">in</span> df_reg.columns <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> ind <span class="kw">in</span> df_reg[<span class="st">'naics_top'</span>].unique():</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ml_flag <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>]:</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>          <span class="co"># model expects `is_ml_job` variable (we set it above), so pass that for prediction</span></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>          row <span class="op">=</span> { <span class="st">'is_ml_job'</span>: ml_flag, <span class="st">'n_skills'</span>: mean_n_skills, <span class="st">'ml_skill_count'</span>: mean_ml_skill_count, <span class="st">'naics_top'</span>: ind }</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>          <span class="cf">try</span>:</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>            pred_res <span class="op">=</span> model.get_prediction(pd.DataFrame([row]))</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>            pred_mean_log <span class="op">=</span> pred_res.predicted_mean[<span class="dv">0</span>]</span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>            pred_mean <span class="op">=</span> <span class="bu">float</span>(np.exp(pred_mean_log))</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>          <span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>            pred_mean <span class="op">=</span> np.nan</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>          preds.append({<span class="st">'naics_top'</span>: ind, <span class="st">'is_ml_job'</span>: <span class="bu">bool</span>(ml_flag), <span class="st">'predicted_salary'</span>: pred_mean})</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>      pred_df <span class="op">=</span> pd.DataFrame(preds).dropna()</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>      <span class="co"># sort industries by total postings to keep consistent order</span></span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>      order <span class="op">=</span> df_reg[<span class="st">'naics_top'</span>].value_counts().loc[<span class="kw">lambda</span> x: x.index.isin(pred_df[<span class="st">'naics_top'</span>])].index.tolist()</span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>      pred_df[<span class="st">'naics_top'</span>] <span class="op">=</span> pd.Categorical(pred_df[<span class="st">'naics_top'</span>], categories<span class="op">=</span>order, ordered<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Map boolean to readable labels and plot side-by-side bars for predicted salary by industry</span></span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>  pred_df[<span class="st">'requires_label'</span>] <span class="op">=</span> pred_df[<span class="st">'is_ml_job'</span>].<span class="bu">map</span>({<span class="va">True</span>: <span class="st">'Jobs requiring ML/DS skills'</span>, <span class="va">False</span>: <span class="st">'Jobs not requiring ML/DS skills'</span>})</span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>  plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>,<span class="dv">7</span>))</span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a>  sns.barplot(data<span class="op">=</span>pred_df, x<span class="op">=</span><span class="st">'naics_top'</span>, y<span class="op">=</span><span class="st">'predicted_salary'</span>, hue<span class="op">=</span><span class="st">'requires_label'</span>)</span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>  plt.xlabel(<span class="st">'Industry (top)'</span>)</span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>  plt.ylabel(<span class="st">'Predicted Salary (USD)'</span>)</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>  plt.title(<span class="st">'Predicted salary by industry — Jobs requiring ML/DS skills vs not (controls at mean)'</span>)</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>  plt.xticks(rotation<span class="op">=</span><span class="dv">25</span>, ha<span class="op">=</span><span class="st">'right'</span>)</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a>  plt.legend(title<span class="op">=</span><span class="st">'Requirement'</span>)</span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>  plt.tight_layout()</span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>  out_png2 <span class="op">=</span> <span class="st">'figures/regression_predicted_salary_by_industry.png'</span></span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a>  plt.savefig(out_png2, dpi<span class="op">=</span><span class="dv">220</span>)</span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'Saved regression predicted-salary figure to'</span>, out_png2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:             log_salary   R-squared:                       0.191
Model:                            OLS   Adj. R-squared:                  0.191
Method:                 Least Squares   F-statistic:                     309.8
Date:                Wed, 08 Oct 2025   Prob (F-statistic):               0.00
Time:                        20:11:08   Log-Likelihood:                -12854.
No. Observations:               30808   AIC:                         2.576e+04
Df Residuals:                   30784   BIC:                         2.596e+04
Df Model:                          23                                         
Covariance Type:                  HC3                                         
======================================================================================================================================================
                                                                                         coef    std err          z      P&gt;|z|      [0.025      0.975]
------------------------------------------------------------------------------------------------------------------------------------------------------
Intercept                                                                             11.3067      0.009   1294.039      0.000      11.290      11.324
is_ml_job[T.True]                                                                     -0.0311      0.015     -2.017      0.044      -0.061      -0.001
C(naics_top)[T.Educational Services]                                                  -0.2659      0.018    -14.947      0.000      -0.301      -0.231
C(naics_top)[T.Finance and Insurance]                                                  0.1542      0.010     14.728      0.000       0.134       0.175
C(naics_top)[T.Health Care and Social Assistance]                                     -0.0751      0.019     -3.963      0.000      -0.112      -0.038
C(naics_top)[T.Information]                                                            0.2528      0.012     20.459      0.000       0.229       0.277
C(naics_top)[T.Manufacturing]                                                          0.1256      0.013      9.645      0.000       0.100       0.151
C(naics_top)[T.Other]                                                                 -0.0396      0.013     -3.073      0.002      -0.065      -0.014
C(naics_top)[T.Professional, Scientific, and Technical Services]                       0.3019      0.009     35.075      0.000       0.285       0.319
C(naics_top)[T.Retail Trade]                                                           0.1250      0.022      5.597      0.000       0.081       0.169
C(naics_top)[T.Unclassified Industry]                                                  0.0511      0.012      4.428      0.000       0.028       0.074
C(naics_top)[T.Wholesale Trade]                                                        0.0582      0.014      4.186      0.000       0.031       0.085
is_ml_job[T.True]:C(naics_top)[T.Educational Services]                                 0.0075      0.026      0.290      0.772      -0.043       0.058
is_ml_job[T.True]:C(naics_top)[T.Finance and Insurance]                               -0.0645      0.019     -3.468      0.001      -0.101      -0.028
is_ml_job[T.True]:C(naics_top)[T.Health Care and Social Assistance]                    0.0758      0.025      3.013      0.003       0.026       0.125
is_ml_job[T.True]:C(naics_top)[T.Information]                                          0.0766      0.023      3.380      0.001       0.032       0.121
is_ml_job[T.True]:C(naics_top)[T.Manufacturing]                                        0.0032      0.024      0.135      0.893      -0.043       0.050
is_ml_job[T.True]:C(naics_top)[T.Other]                                               -0.0328      0.020     -1.618      0.106      -0.072       0.007
is_ml_job[T.True]:C(naics_top)[T.Professional, Scientific, and Technical Services]    -0.2256      0.018    -12.484      0.000      -0.261      -0.190
is_ml_job[T.True]:C(naics_top)[T.Retail Trade]                                         0.0471      0.033      1.421      0.155      -0.018       0.112
is_ml_job[T.True]:C(naics_top)[T.Unclassified Industry]                               -0.0603      0.021     -2.822      0.005      -0.102      -0.018
is_ml_job[T.True]:C(naics_top)[T.Wholesale Trade]                                     -0.0459      0.034     -1.343      0.179      -0.113       0.021
n_skills                                                                               0.0036   7.65e-05     46.942      0.000       0.003       0.004
ml_skill_count                                                                        -0.0044      0.001     -3.682      0.000      -0.007      -0.002
==============================================================================
Omnibus:                      561.884   Durbin-Watson:                   1.929
Prob(Omnibus):                  0.000   Jarque-Bera (JB):              619.562
Skew:                          -0.304   Prob(JB):                    2.91e-135
Kurtosis:                       3.336   Cond. No.                     1.62e+03
==============================================================================

Notes:
[1] Standard Errors are heteroscedasticity robust (HC3)
[2] The condition number is large, 1.62e+03. This might indicate that there are
strong multicollinearity or other numerical problems.
Saved regression predicted-salary figure to figures/regression_predicted_salary_by_industry.png</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="regression_classification_files/figure-html/cell-5-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="conclusion" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">1.1</span> Conclusion</h2>
<p>Both models highlight that while ML/DS skills correlate with higher earning potential in specific industries—particularly Information and Professional &amp; Technical Services—the overall job-market premium is not universal. This suggests that data-driven expertise remains concentrated in certain sectors, offering a clear signal for students to prioritize industry context when developing advanced analytical skills.</p>
</section>
</section>
<section id="analysis-1" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Analysis</h1>
<p>Based on the KMeans clustering, we expected to see higher salaries across industries for roles requiring machine learning and data science skills. However, the regression results showed that only Information and Retail Trade—along with “Other”—had higher salaries for jobs requiring those skills. This suggests that while job postings requiring ML/DS skills tend to include higher salary outliers, the overall demand for these skills may still be relatively niche. In many industries, organizations may not yet know how to fully incorporate machine learning and data science into their operations, meaning that the highest-paying roles still emphasize more traditional skill sets. It’s likely that performing this same analysis five or ten years from now would yield very different results as these skills become more widely adopted and in demand across currently slower-to-adapt industries.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>